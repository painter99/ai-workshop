## Session: List Indexing, Tuples & Slicing Foundations (2025-12-29)

### Co jsem se nauÄil

**1. List Indexing â€“ Zero-Based Access**
- Index zaÄÃ­nÃ¡ od NULY: `my_list[0]` = prvnÃ­ prvek
- DruhÃ½ prvek = index 1 (ne 2!)
- NegativnÃ­ indexing: `my_list[-1]` = poslednÃ­ prvek (super elegantnÃ­!)
- SYNTAX MATTERS: `[]` pro indexing (subscript), `()` pro funkce
- TypickÃ¡ chyba: `my_list(1)` vs. sprÃ¡vnÄ› `my_list[1]` â†’ TypeError!

**2. Tuples = Immutable Lists**
- VytvoÅ™enÃ­: `my_tuple = ("car", "house", "airplane")` â†’ kulatÃ© zÃ¡vorky!
- Vlastnost: CANNOT change prvky po vytvoÅ™enÃ­
- Pokus o zmÄ›nu: `my_tuple[1] = "boat"` â†’ **TypeError: 'tuple' object does not support item assignment** âŒ
- RozdÃ­l od listÅ¯: list=zmÄ›nit lze, tuple=NE
- Indexing funguje stejnÄ›: `my_tuple[0]`, `my_tuple[-1]`
- Use case: kdyÅ¾ chceÅ¡, aby data byla "locked" (nemÄ›nnÃ¡)

**3. List Slicing â€“ Getting Multiple Elements**
- Syntax: `my_list[start:end:step]`
- **KlÃ­Ä**: start=INCLUSIVE, end=EXCLUSIVE (poslednÃ­ index se NEZAHRNUJE!)
- PÅ™Ã­klad: `my_list[1:3]` â†’ prvky index 1 a 2 (ne 3!)
- Se stepem: `my_list[::2]` â†’ kaÅ¾dÃ½ druhÃ½ prvek (od zaÄÃ¡tku do konce)
- Moje chyba: Napsal jsem `my_list[2:4]` namÃ­sto `my_list[1:3]` â€“ Å¡patnÄ› poÄÃ­tÃ¡m offset!

**4. Mutability = Key Difference**
- **List**: `my_list[1] = "updated"` âœ… Funguje! (mutable)
- **Tuple**: StejnÃ¡ operace âŒ TypeError! (immutable)
- To je HLAVNÃ rozdÃ­l â€“ list pro dynamickÃ¡ data, tuple pro fixnÃ­ data

**5. Type Conversion â€“ int() a str()**
- String â†’ Integer: `int("123")` â†’ 123 (pak mÅ¯Å¾eÅ¡ poÄÃ­tat)
- Integer â†’ String: `str(456)` â†’ "456" (pro text manipulaci)
- ProÄ? RÅ¯znÃ© operace vyÅ¾adujÃ­ rÅ¯znÃ© typy

**6. Why Zero-Indexing Makes Sense**
- Index = OFFSET od zaÄÃ¡tku pamÄ›ti, ne "poÅ™adÃ­"
- Symetrie: `len(list) = 3` + `range(0, len(list))` = [0, 1, 2] âœ…
- Kdyby se indexovalo od 1: `range(1, len(list)+1)` = hacky! âŒ
- Memory perspective: poÄÃ­taÄ si myslÃ­ v offsetech, ne v "poÅ™adÃ­ch"

### Blockers & Resolution
- **Syntax confusion (zÃ¡vorky)**: `my_list(1)` mÃ­sto `my_list[1]` â†’ Anna mÄ› upozornila âœ…
- **Slicing off-by-one error**: `[2:4]` mÃ­sto `[1:3]` â†’ musÃ­m si pamatovat: end je EXCLUSIVE âœ…
- **Role Play timeout**: 10 minut na session â†’ stihli jsme 3/4 goals, poslednÃ­ `str()` je triviÃ¡lnÃ­ âœ…
- **Time pressure**: PoslednÃ­ goal jsem nestihl, ale mÃ¡Å¡ si pÅ™ipomenut, Å¾e je to OK â€“ pokud chÃ¡pÃ¡Å¡ logiku âœ…

### LogickÃ© MyÅ¡lenÃ­ (Lessons from Today)
- Role Play chat = skvÄ›lÃ½ way to learn
- NegativnÃ­ indexing: NejdÅ™Ã­v "proÄ to funguje?" (offset logika), pak psanÃ­ kÃ³du
- Slicing je "vÄetnÄ›-nevÄetnÄ›" asymetrie â€“ MUSÃM si to zapamatovat

### Next Steps
- Sekce 5: `enumerate()` â€“ iterace S INDEXEM (ne jen hodnotou)
- Pak: `break`, `continue` statement (control flow)
- TODO app: refactor "show" funkci s enumerate (bude lÃ©pe!)
- BudoucÃ­: list comprehension, slovnÃ­ky (dict)

### Lesson Quote
"Zero-indexing nenÃ­ random choice. Je to PÅ˜ÃMÃ reprezentace toho, jak poÄÃ­taÄ vidÃ­ pamÄ›Å¥ â€“ offset od zaÄÃ¡tku. ChÃ¡pat to znamenÃ¡ chÃ¡pat samotnÃ½ hardware myÅ¡lenÃ­ Pythonu."

---

**AbsolvovanÃ¡ lekce:** Sekce 4/57 (List Indexing, Tuples, Slicing, Type Conversion) âœ…
**Role Play Goals:** 3/4 completed (+ knowledge na 4.) ğŸ¯
**Key Takeaway:** Offset thinking > poÅ™adÃ­ thinking. AsymetrickÃ¡ slicing (`[1:3]`) = inclusive-exclusive pattern. ğŸ’¡
